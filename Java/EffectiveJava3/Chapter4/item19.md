# 아이템19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
## 상속을 고려한 설계와 문서화
- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
    - 재정의 가능 메서드를 호출할 숙 있는 모든 상황을 문서로 남겨야 한다.
    - 메서드 주석에 @impleSpec 태그를 붙이면 자바독 도구가 생성해줌
    - @impleSpec 태그는 명령줄 매개변수로 `-tag "impleSpec:a:Implementation Requirements:`를 지정
    - ex) java.util.AbstractCollection remove()
- 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 *클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있음*
    - ex) java.util.AbstractList removeRange()
- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 '유일'하다
    - 하위 클래스는 3개 정도가 적당
    - 하나 이상은 제 3자가 작성 해봐야 함
- 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 함
    - 문서화한 내부 사용 패턴과, protected 메서드와 필드는 클래스의 성능과 기능에 영원한 족쇄가 될 수 있음 
## 상속을 허용하는 클래스가 지켜야 할 제약
- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 됨
    - 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출됨
    - 재정의한 메서드 생성자에서 초기화하는 값에 의존한다면 프로그램이 오동작 함
    - private, final static 메서드는 재정의가 불가능하니 생성자에서 안심하고 호출해도 됨
    - clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 됨
    - readObject는 하위 클래스의 상태가 다 역직렬화되기 전에 재정의한 메서드부터 호출하게 됨
    - clone은 하위 클래스의 clone 메서가 복제본의 상태를 (올바른 상태로) 수정하기 전에 재정의된 메서드를 호출함
- Serializable을 구현한 상속용 클래스가 readResolve나 writePlace메서드를 갖는다면 이 메서드들은 private이 아닌 protected로 선언해야 함
    - private으로 선언하면 하위클래스에서 무시 됨
- 클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 안기는 제약이 상당함
## 가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지
- 클래스를 final로 선언
- 모든 생성자를 private or package-private으로 선언하고 public 정적 팩토리 제공
- 상속을 꼭 해야겠다면 재정의 가능 메소드를 사용 하지 말고 이 사실을 문서로 남김

## 클래스의 동작을 유지하면서 재정의 가능 메서드를 사용하는 코드를 제거하는 기계적인 방법
1. 재정의 메서드의 본문 코드를 private '도우미 메서드'로 옮김
2. 재정의 가능 메서드를 호출하는 코드를 도우미 메서드를 직접 호출하도록 수정

## 핵심정리
- 상속용 클래스를 설계하기란 결코 만만치 않음
- 클래스 내부에서 스스로를 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야하며, 그 클래스가 쓰이는 한 반드시 지켜야 함
- 그렇지 않으면 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 있음
- 효율 좋은 하위 클래스를 만들 수 있도록 메서드를 protected로 제공해야할 수 있음
- 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 나음
- 상속을 금지하려면 클래스를 final로 선언 or 생성자 모두를 외부에서 접근할 수 없도록 만듦

    


