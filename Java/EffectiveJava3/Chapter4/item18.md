# 아이템 18, 상속보다는 컴포지션을 사용하라
##메서드 호출과 달리 상속은 캡슐화를 깨뜨림
- 상위 클래스의 구현에 따라 하위클래스 동작에 이상이 생길 수 있음
- ex) *자기사용(self-use)* HashSet의 AddAll은 내부적으로 add메서드를 실행함
- 새로운 메서드를 추가해도 여전히 위험
- 상위 클래스에서 추가한 메서드의 시그니쳐가 하위 클래스에서 추가한 메서드와 같은 경우
## 컴포지션
- 기존클래스를 확장하는 대신, 새 클래스를 만들고 private필드로 기존 클래스의 인스턴스를 참조
- 전달 메서드
    - 전달? 새 클래스의 인스턴스 메서드들은 기존 클래스의 대응하는 메서드를 호출해 결과를 반환
- 기존 클래스의 내부 구현 방식의 영향에서 벗어남
- 기존 클래스에 새로운 메서드가 추가되더라도 영향 X
- 이러한 클래스를 래퍼 클래스라고 함
- 데코레이터 패턴이라고도 함
- 컴포지션과 전달의 조합은 넓은 의미로 위임(delegation)이라고 부름
    - 엄밀히 따지면 래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우에만 위임에 해당함
- 래퍼 클래스 주의사항
    - 콜백 프레임워크와는 어울리지 않음
    - SELF 문제
        - 콜백 프레임워크에서는 자기 자신의 참조를 다른객체에 넘겨서 다음 호출 때 사용하도록 함
        - 내부 객체는 자신을 감싸고 있는 래퍼의 존재를 모르니 자신(this)의 참조를 넘기고, 콜백 때는 내부 객체를 호출함
- 재사용 가능한 전달 클래스를 인터페이스 당 하나씩만 만들어두면 원하는 기능을 덧씌우는 전달 클래스들을 아주 손쉽게 구현 가능
    - ex) 구아바
## 상속을 해야하는 상황
- is-A 관계일 때만
- 자바 플랫폼 라이브러리에서도 위 원칙을 명백히 위반한 클래스가 존재
    - ex) Stack extends Vector, Properties extends HashTable  
## 컴포지션을 써야 할 상황에서 상속을 사용시 단점
- 내부 구현을 불필요하게 노출
- API가 내부 구현에 묶임
    - 클래스의 성능도 영원히 제한
- 클라이언트가 노출된 내부에 직접 접근 가능
- 사용자를 혼란스럽게 함
    - ex) Properties.getProperty, Properties.get
- 클라이언트에서 상위 클래스를 직접 수정하여 하위 클래스의 불변식을 해칠 수 있음
## 컴포지션 대신 상속을 사용하기로 결정 하기전에 자문해야할 질문
- 확장하려는 클래스의 API에 아무런 결함이 없는가?
- 결함이 있다면, 이 결함이 여러분 클래스의 API까지 전파돼도 괜찮은가?

## 핵심정리
- 상속은 강력하지만 캡슐화를 해침
- 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 사용
- is-a관계일 때도 하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았따면 여전히 문제가 될 수 있음
- 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용
- 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 그럼
- 래퍼 클래스는 하위 클래스보다 견고하고 강력함