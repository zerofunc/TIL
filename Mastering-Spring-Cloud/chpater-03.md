# 스프링 클라우드 개요
## 12-팩터 앱 (The Twelve-Factor App)
    - https://12factor.net/ko/
    - 확장 가능하고 쉽게 클라우드 플랫폼에 배포 가능하며 지속 배포 프로세스에 따라 배포되는 *Software as a Service(SASS)*를 개발하는 방법론
    - 스프링 부트와 스프링 클라우드에서 12-팩터 룰에 부합하는 애플리케이션을 만드는 기능과 요소를 제공함
    - ex) 분산/버전 컨피규레이션, 서비스 등록 및 디스커버리, 라우팅, 서비스 간의 호출, 부하 분산, 서킷 브레이커, 분산 메시징
## 기본부터 시작하기
- 표준 스프링 부트 애플리케이션과 달리 스프링 클라우드는 원격 서버에서 컨피규레이션을 가져옴
    - 부트스트랩 컨텍스틑에 애플리케이셔 내에 필요한 최소 설정
    - ex) 애플리케이션 이름과 컨피규레이션 서버 주소 설정   
- 부트스트랩 컨테스트?
    - 메인 애플리케이션 컨텍스트의 부모(parent)
    - `application.yml` 대신 `bootstrap.yml` 사용
    ```yaml
    spring:
      application:
        name: person-service
      cloud:
        config:
          uri: http://192.168.99.100:8888
    ```  
- 부트스트랩 설정
    - 비활성화
        - spring.cloud.bootstrap.enabled = false
    - 컨피규레이션 파일 이름
        - spring.cloud.bootstrap.name
    - 설정 파일 위치 변경
        - spring.cloud.bootstrap.location
    - 스프링 부트 액추에이터에 포함된 관리 종단점
        - env : Environment를 위한 새로운 POST 메서드, 로그 레벨 변경, @ConfigurationProperties 리바인드
        - refresh : 부트스트랩 컨택스트를 다시 로드하고, @RefreshScope 애노테이션이 있는 빈을 리프레시
        - restart : 스프링의 ApplicationContext를 재시작
        - pause : 스프링의 ApplicationContext를 중지
        - resume : 스프링의 ApplicationContext를 시작
- 스프링 클라우드 프로젝트 부모 의존성으로 포함된 라이브러리
    - Spring Cloud Commmons
    - 서비스 디스커버리, 부하 분산, 서킷 브레이커 등의 메커니즘을 위한 공통의 추상 레이어 제공
## 넷플릭스(Netflix) OSS
- 넷플릭스는 모놀리식에서 클라우드-네이티브 마이크로서비스 기반 개발 방식으로 전환한 선구자
- 솔루션 라이브러리 기반의 수많은 오픈 소스 프레임워크 공개됨
- 스프링 클라우드와 통합
    - 유레카(Eureka)
    - 히스트릭스(Hystrix)
    - 리본(Ribbon)
    - 주울(Zuul) 등..
- 넷플릭스가 코드 대부분을 공개하기로 했는지 이해할 수 있는 단서
- *"우리(넷플릭스)가 넷플릭스의 모든 것을 클라우드로 옮길 것이라고 헀을 때 모두가 완전히 미쳤다고했다. 그들은 우리가 실제로 해냈다고 믿지 않고 꾸며낸 것이라고 생각했다."*                
## 유레카를 사용한 서비스 디스커버리
- 클라이언트와 서버로 구분됨
- 클라이언트
    - 유레카 클라이언트를 프로젝트에 포함하는 법
        - `spring-cloud-starter-eureka` 스타터 사용
    - 디스커버리 서버에 연결하는 일을 담당
    - 연결되면 서비스 이름과 네트워크 위치를 담은 등록 메시지를 보냄
    - 다른 마이크로서비스로의 종단점 호출 시 클라이언트는 서버로부터 등록된 서비스 목록을 담은 최신 컨피규레이션을 가져옴
- 서버
    - 독릭적인 스프링 부트 애플리케이션으로 설정되고 실행 됨
    - 유레카 서버를 프로젝트에 포함하는 법
        - `spring-cloud-starter-eureka-server` 스타터 사용
## 주울을 사용한 라우팅
- 주울?
    - JVM 기반의 라우터
    - 서버 측 부하 분산과 일부 필터링을 수행
    - 넷플릭스 활용 사례
        - ex) 인증, 부하 평균 분배, 정적 응답 처리, 부하 테스트
    - 독릭적인 스프링 부트 애플리케이션으로 설정되고 실행 됨
- 프로젝트 포함하는 법
    - `spring-cloud-starter-zuul` 스타터 사용
- API 게이트웨이로서 중요한 역할
- 각 서비스의 네트워크 위치 정보를 알아야 함
    - 유레카 서버와 통신하기 위해 디스커버리 클라이언트를 클래스 경로에 포함
## 리본을 사용한 부하 분산
- 클라이언트 측 부하 분산기
- 지원 프로토콜
    - TCP, UDP, HTTP 등 가장 유명한 프로토콜을 지원함
- 동기방식의 REST 호출, 비동기 또는 리액티브 모델도 지원함
- 서비스 디스커버리, 캐싱, 일괄 처리, 장애 내성과 통합 가능
- 기본 HTTP와 TCP 클라이언트를 한 단꼐 더 추상화함
- 프로젝트에 포함하는 법
    - `spring-cloud-starter-ribbon` 스타터 사용
- 부하 분산을 하는 규칙을 즉시 제공, 사용자 정의 규칙을 쉽게 확장 가능            
- 네임드 클라이언트(named client)개념에 기반함
## 자바 HTTP 클라이언트 작성하기
- 페인?
    - 선언적 REST 클라이언트
    - 애노테이션을 선언해 사용
- 프로젝트에 포함하는 법
    - `spring-cloud-starter-feign` 스타터 사용
- 리본 클라이언트와 통합 가능
    - 디스커버리 서비스와의 통신, 부하 분산 같은 리본의 기능을 기본으로 사용
## 히스트릭스를 사용해 대기 시간 및 장애 내성 다루기
- 서킷 브레이커 패턴을 구현한 라이브러리
- 리본과 페인 클라이언트를 통합할 수 있음
- 폴랙은 서킷 브레이커 개념과 매우 밀접
- 프로젝트에 포함하는 법
    - `spring-cloud-starter-hytrix` 스타터 사용       

## 아카이우스를 사용한 컨피규레이션 관리
- 변경 전의 원본을 가져오거나 변경사항을 클라이언트에 전달하는 방법으로 컨피규레이션을 갱신함

## 디스커버리와 분산 컨피규레이션
- MSA에서 중요한 부분
- 유연한 키-값 저장소에 특정 키와 값을 저장하는 것
- 스프링 클라우드만의 특징
    - 분산 설정 기능을 직접 구현함
- 스프링 클라우드 컨피그 프로젝트에 존재
- 서버 측과 클라이언트 측으로 나뉨
- 서버 측 
    - 단 하나의 중앙의 장소
    - 애플리케이션을 위한 모든 외부 속성이 모든 환경에 대해 서버에서 관리됨
    - 컨피규레이션은 여러 버전과 프로파일로 동시에 유지됨
    - 이것은 저장소 백엔드로 깃을 사용함 <=(..?)
    - 설정 파일은 파일 시스템 또는 서버 클래스 경로에 있을 수 있음
    - 또는 볼트 - made by 해시코트
- 컨피그 서버
    - REST API에 속성을 노출하는 독립된 스프링 부트 애플리케이션을 실행됨
    - `spring-cloud-config-server` 의존성 추가해 활성화
- 클라이언트 측 
    - 컨피규레이션 서버를 속성 저장소로 사용하는 모든 마이크로서비스 클라이언트는 시작 시 스프링 빈이 생성되기 전에 컨피규레이션 서버에 접속함
    - 스프링 클라우드 컨피그 클라이언트 활성화 방법
        - `spring-cloud-config-starter` 의존성 추가해 활성화
## 또 다른 대안 - 컨설
- 넷플릭스 디스커버리와 스프링 분산 컨피규레이션의 흥미로운 대안
- made by 해시코프               
- 스프링 클라우드에서 컨설과의 통합을 지원함
- 컨설 서버에 연결하기 위해 애플리케이션 에이전트가 필요
- 별도로 분리된 프로세스로 실행해야함
- 기본 주소 : https://localhost:8500
- 컨설 아키텍처 https://www.consul.io.docs.internals/architecture.html
- `spring-cloud-starter-consul-discovery` 의존서 추가해 사용
- 클라이언트 애플리케이션 시작 후 컨설 서버에 등록되면 클라이언트가 다른 서비스 목록을 가져오기 위해 컨설에 물어봄
- 지원 항목
    - 넷플릭스 리보과 동적 라우터, 넷플릭스 주울의 필터
## 아파치 주키퍼
- 컨피규레이션과 이름을 유지하는 중앙 서비스로의 분산 동기화, 그룹 서비스를 가능하게 함
- 컨설에 적용되는 스프링 클라우드와 관련된 모든 것이 주키퍼에도 적용됨
    - ex) 공통 애노테이션을 통한 통합제공, 설정 파일의 속성을 통한 컨피규레이션, 리본 또는 주울과 상호작용하기 위한 자동-컨피규레이션 등..
- 클라이언트에서 주키퍼를 사용한 서비스 디스커버리 사용하는 법
    - `spring-cloud-starter-zookeeper-discovery` 의존성 추가
    - 아파치 큐레이터(Curator) 의존성 추가
- 큐레이터?
    - 통합을 쉽고 믿을 만하게 해주는 API 프레임워크와 유틸리티를 제공함
- 분산 컨피규레이션 클라이언트 활성화 하는 법
    - `spring-cloud-starter-zookeeper-config` 의존성 추가        
## 기타 프로젝트
- 인큐베이션 단계에 있는 프로젝트
- https://github.com/spring-cloud-incubator
- 쿠버네티스(Kubernetes)
    - 배포, 확장, 애플리케이션 컨테이너의 관리를 자동화하는 시스템
    - 컨테이너 오케스트레이션(orchestration) 및 서비스 디스커버리, 컨피규레이션 관리, 부하 분산 등..
    - 스프링 클라우드 관점에서 가장 중요한 기능
        - 서비스 디스커버리와 분산컨피규레이션 메커니즘
        - `spring-cloud-starter-kubernetes` 스타터를 포함해 사용 가능
- 스프링 클라우드 에티시디(Etcd)
    - 주요기능
        - 분산 컨피규레션, 서비스 등록, 디스커버리
    - 클라우드 환경에서 분산 키-값 저장소를 신뢰성 있제 제공함
    - 쿠버네티스에서 서비스 디스커버리, 클러스터 상태, 컨피규레이션 관리에 쓰이는 백엔드
## 슬루스를 사용한 분산 추적
- 가장 주용한 목표 : 하나의 요청을 여러 마이크로서비스로 처리할 때 이어지는 요청을 연관 짓는 것
- 대부분 HTTP 헤더에 기반한 메커니즘으로 추적을 구현함
- Slf4j와 MDC로 개발됨
- Slf4j의 역할
    - 로그백이나 log4j, java.util.logging 등과 같은 로깅 프레임워크의 추상화 퍼사드를 함
- MDC(mapped diagnostic context)
    - 다양한 소스의 로그 출력을 구분
    - 실제 범위에 없던 부가 정보를 추가
- 트레이스(trace) Id와 스팬(span) ID를 Slf4jj MDC에 추가해 트레이드(trace) 또는 스팬(span)으로 모든 관련된 로그 추출 가능
- REST템플릿, 페인 클라이언트, 주울 필터, 히스트릭스, 스프링 인테크레이션 메시지 채널등의 가장 유명한 메시징 솔루션과 통합됨
- RxJava, 스케줄된 태스크와도 험께 사용가능
- `spring-cloud-starter-sleuth` 의존성 추가해야 사용 가능
- 지연 분석을 위한 기간 정보도 기록함
- 통계 정보를 집킨 도구에 제공 가능

> 집킨은 마이크로서비스 아키텍처 내부의 지연 문제를 분석하기 위해 설계된 분산 추적 시스템.
> 이것은 입력 데이터를 수집하기 위한 HTTP 종단점을 노출함
> 집킨으로 추적 데이터를 생성해 보내려면 spring-cloud-starter-zipkin의존성을 프로젝트에 추가하면 됨
- 트래픽 양이 너무 클 때
    - 샘플링 정책 
        - 집킨으로 보낼 트래픽 양 조절 가능
    - 기본 HTTP 종단점 대신 메시지 브로커에 통계 정보를 보냄
        - `spring-cloud-sleuth-stream` 의존성을 추가해 기능 활성화
        - 애플리케이션은 메시지를 보내는 프로듀서(producer)가 된다.
## 메시징과 통합
- 스프링 클라우드 버스
    - 컨피규레이션 속성 변경이나 다른 관리 명령등의 상태 변경을 브로드 캐스트 이벤트(broadcast event)로 애플리케이션에 알릴 수 있음
    - 래빗엠큐나 아파치 카프카를 사용하는 AMQP 스타터 사용
    - `spring-cloud-starter-bus-amqp` 의존성 추가
    - `spring-cloud-starter-bus-kafka` 의존성 추가
    - 컨피규레이션 변경 이벤트의 전달 등 공통 오퍼레이션을 위한 분산 메시징 기능 사용 가능
- 스프링 클라우드 스트림
    - 메시지 중심 마이크로서비스로 구성된 시스템을 개발하기 위한 올바른 프레임워크
    - 두 개의 바인더
        - 래빗엠큐를 사용하는 AMQP
        - 아파치 카프카
    - 종단점, 채널, 애그리게이터(aggregator), 트랜스포머(transformer)와 같은 대부분의 엔터프라이즈 통합 패턴을 지원하는 프로그램 모델 제공
    - 전체 마이크로서비스 시스탬 내의 애플리케이션은 스프링 클라우드 스트림 입력 및 출력 채널을 통해 통신함
    - 스프링 클라우드 스트림에서 그루핑(grouping) 메커니즘을 만든 이유
        - 게시/구독 모델에서는 메시지가 하나의 인스턴스에서 처리되지 않음
    - 바인더
        - `spring-cloud-starter-stream-kafka` 의존성 추가
        - `spring-cloud-starter-stream-rabbit` 의존성 추가
- 스프링 클라우드 스트림 앱 스타터(Spring Cloud Stream App Starter)
    - 독립적으로 실행되는 스프링 클라우드 애플리케이션을 정의
    - 프로젝트인 스프링 클라우드 데이터 플로우를 사용하는 스프링 클라우드 스트림 애플리케이션을 정의함
    - 커네턱, 네트워크 프로토콜 어댑터, 범용 프로토콜을 구분 가능
- 스프링 클라우드 데이터 플로우
    - 데이터 통합과 실시간 데이터 처리 파이프라인을 만들기 위한 유용한 솔루션을 제공해 개발과 배포를 간단하게 만듦
    - 마이크로서비스 기반 데이터 파이프라의 오케스트레이션이 수행할 수 있는 것
        - 간단한 DSL
        - 드래그 앤드 드롭 UI 대시보드
        - REST API
## 클라우드 플랫폼 지원
- 피보탈 클라우드 파운드리(PCF, Pivotal Cloud Foundry)
    - 최신 애플리케이션을 배포하고 관리하는 클라우드 네이티브 플랫폼
    - 의존성
        - `spring-cloud-services-starter-circuit-breaker`
        - `spring-cloud-services-starter-config-client`
        - `spring-cloud-services-starter-service-registry`
- 아마존 웹 서비스를 위한 모듈
    - Spring Cloud AWS Core
        - `spring-cloud-starter-aws` 스타터로 활성화
        - EC2인스턴스로 직접 접근을 활성화하는 핵심 구성 요소 제공
    - Spring Cloud AWS Context
        - S3 저장소, 이메일 서비스, 캐싱 서비스로의 접근 제공
    - Spring Cloud AWS JDBC
        - `spring-cloud-starter-aws-jdbc` 스타터로 활성화
        - 스프링에서 지원하는 데이터 접근 기술을 사용할 수 있는 데이터 소스 조회 및 컨피규레이션 제공
    - Spring Cloud AWS Messaging
        - `spring-cloud-starter-aws-messaging` 스타터로 활성화
        - 애플리케이션이 SQS(점대정 메시징) 또는 SNS(게시/구속 메시징)로 메시지를 보내고 받을 수 있게 함
- 스프링 클라우드 커넥터 프로젝트
    - 클라우드 플랫폼에 배포된 JVM 기반 애플리케이션ㅇ늘 위한 추상화를 제공
    - 애플리케이션이 스프링 클라우드 히로쿠 커넥터와 스프링 클라우드 파운드리 커넥터 모듈을 사용해 SMTP, 래빗엠큐, 레디스(Redis) 또는 전통적인 데이터베이스에 접속할 수 있는 클라우드 플랫폼                                    
## 다른 유용한 라이브러리
### 보안
- 스프링 클라우드 시큐리티
    - 싱글 사인온(single sign-on), 토큰 리플레이(token replay)와 같은 일반적인 패턴을 구현하는 시스템을 개발하기 쉽게 도와줌
    - `spring-cloud-starter-security` 스타터를 포함해 보안 관리 활성화
### 테스트 자동화
- MSA에서 컨트랙트 테스트(Contract Test)의 중요성이 점점 커짐
- 마틴 파울러의 정의 (Martin Fowler)
    - *"통합 컨트랙트 테스트(intergration contract test)는 소비자가 기대하는 계약을 서비스가 만족하는지 검증하는 테스트다."*
- 스프링 클라우드 컨트랙트
    - 트래픽을 기록할 때 와이어목(wireMock)을 사용
    - 스텁(stub)을 생성하는 데 메이븐 플러그인 사용
- 스프링 클라우드 태스크    
    - 스프링 클라우드를 사용해 한 번만 실행하고 종료하는 마이크로서비스를 개발하도롥 도와줌
    - 로컬 컴퓨터나 클라우드 환경에서 실행함
    - `spring-cloud-starter-task` 스타터로 활성화
### 클러스터 기능
- 스프링 클라우드 클러스터
    - 주키퍼, 레디스, 해즐캐스트(HazelCast), 컨설에 대한 추상화 및 구현을 사용
    - 리더 선출과 공통 상태유지 패턴을 위한 솔루션 제공
## 릴리즈 트레인(release trains)
- 하위 프로젝트의 혼란을 피하기 위해 릴리즈를 버전이 아닌 이름으로 구분
    - ex) Angel, Brixton ..
- 의존성 관리 메커니즘은 BOM(Bill of materials)에 기반함
    - 아티팩트 버전을 독립적으로 관리하는 표준 메이븐 개념
- M[X]의 M은 마일스톤(milestone), X는 버전 번호
- SR[X]는 서비스 릴리즈(service release)로서 중요한 버그를 수정한 버전
- 최신 릴리즈 목록 https://projects.spring.io/spring-cloud/
```groovy
dependecyManageMent {
    imports {
        mavenBom ':spring-cloud-dependencies:Finchley.M2'
    }
}
dependencies {
    compile ':spring-cloud-starter-config'
}

```                